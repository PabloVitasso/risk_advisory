<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Why I make Claude argue with itself before writing code - the Plan, Critique, Build, Validate workflow">
    <title>Why I Make Claude Argue With Itself Before Writing Code - The Skills Team</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header class="hero hero-small">
        <h1>Why I Make Claude Argue With Itself Before Writing Code</h1>
        <p class="blog-meta">January 2026</p>
        <p><a href="./">← Back to blog</a></p>
    </header>

    <main>
        <article class="section blog-post">
            <p>I asked Claude to "make my scraper robust." It generated 200 lines of plausible-looking code: retry logic, logging config, pagination handling.</p>

            <p><strong>All garbage.</strong></p>

            <p>The retry logic used a pattern that didn't match my codebase. The logging config was global (breaking other modules). The pagination had no max-page guard - infinite loop waiting to happen.</p>

            <p>The code <em>looked</em> professional. It would have passed a cursory review. But it was built on assumptions, not understanding.</p>

            <h2>The Problem With "Just Code It"</h2>

            <p>Here's what happens when you ask AI to code without planning:</p>

            <ol>
                <li><strong>It guesses</strong> - No context about your codebase, so it invents patterns</li>
                <li><strong>It confirms itself</strong> - One voice, one blind spot. No challenge.</li>
                <li><strong>It ships fast</strong> - The first idea becomes the implementation</li>
            </ol>

            <p>By the time you catch the issues, you've already committed to a bad approach. Rework is expensive.</p>

            <h2>What I Do Instead</h2>

            <p>I make Claude argue with itself.</p>

            <p>Before any code gets written, I force a structured conversation:</p>

<pre><code>Me: "Add input validation to the login form"

Peter (Planner): "Here's the approach: validate email format,
check password strength, sanitize inputs before DB..."

Neo (Critic): "What about rate limiting? You're checking format
but not preventing brute force. Also, the existing auth module
already has a sanitize() function - don't reinvent it."

Peter: "Good catch. Revised plan: reuse auth.sanitize(),
add rate limiting at the route level, then validate format..."</code></pre>

            <p>Only after the plan survives critique does Gary (the builder) write code. And Reba (QA) reviews before it merges.</p>

            <p><strong>Plan. Critique. Build. Validate.</strong></p>

            <h2>Why This Works</h2>

            <p>It's not magic. It's just structure:</p>

            <ul>
                <li><strong>Multiple perspectives</strong> catch blind spots one voice misses</li>
                <li><strong>Planning before coding</strong> prevents the "first idea ships" trap</li>
                <li><strong>Explicit critique</strong> surfaces assumptions before they become bugs</li>
                <li><strong>Review before merge</strong> catches what planning missed</li>
            </ul>

            <p>This pattern is emerging everywhere. Devin, Cursor's agent mode, serious AI coding workflows - they're all converging on the same structure. Plan before you build.</p>

            <h2>The Implementation</h2>

            <p>I built a set of Claude Code skills that work as a team:</p>

            <table>
                <thead>
                    <tr>
                        <th>Role</th>
                        <th>What They Do</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Peter</strong></td>
                        <td>Plans the approach, identifies risks</td>
                    </tr>
                    <tr>
                        <td><strong>Neo</strong></td>
                        <td>Challenges the plan, plays devil's advocate</td>
                    </tr>
                    <tr>
                        <td><strong>Gary</strong></td>
                        <td>Builds from the approved plan</td>
                    </tr>
                    <tr>
                        <td><strong>Reba</strong></td>
                        <td>Reviews everything before it ships</td>
                    </tr>
                </tbody>
            </table>

            <p>They're personas in the same context - not isolated agents. They can hear each other, interrupt, challenge in real-time.</p>

            <p>You give them a task:</p>

<pre><code>/team "add input validation to login"</code></pre>

            <p>They figure out the handoffs. Peter plans, Neo critiques, Gary builds, Reba validates. You get code that's been argued over before you even look at it.</p>

            <h2>Try It</h2>

            <p>The skills are open source: <a href="https://github.com/HakAl/team_skills">github.com/HakAl/team_skills</a></p>

<pre><code>git clone https://github.com/HakAl/team_skills.git
cp -r team_skills/* ~/.claude/skills/</code></pre>

            <p>Then in Claude Code:</p>

<pre><code>/team "your task here"</code></pre>

            <p>Watch them argue. Ship better code.</p>

            <hr>

            <p><em>The team that wrote this post: Peter planned it, Neo said "don't be preachy," Gary wrote it, Reba approved it. Meta, but true.</em></p>
        </article>
    </main>

    <footer>
        <p>
            <a href="https://github.com/HakAl/team_skills">GitHub</a> ·
            <a href="../">Home</a> ·
            Built by the Skills Team
        </p>
    </footer>
</body>
</html>
